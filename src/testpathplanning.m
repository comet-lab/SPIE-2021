%% Script to test RRT and collision detection
clc, clear, close all

% How many configuration points should we sample for testing?
nPoints = 10;

fprintf('*** RRT and estimation of reachable workspace test ***\n')
fprintf('This script is divided in two parts:\n')
fprintf('1. "Step-by-step" testing of RRT\n');
fprintf('2. Generation of plots to show the results of RRT and of the estimation of the reachable workspace\n\n')
fprintf('Press any key to continue.\n')
pause

% add dependencies
addpath('kinematics')
addpath('utils')
addpath('utils/stlTools')
addpath('path-planning')
addpath('../anatomical-models')

%% Part 1. Step-by-step testing of RRT
fprintf('Testing RRT...\n')
% define the robot's range of motion
maxDisplacement = 1e-3;  % [m]
maxRotation     = 2*pi;  % [rad]
maxAdvancement  = 10e-3; % [m]

% Load cavity model
path = fullfile('..', 'anatomical-models', 'synthetic-model.stl');
[vertices, faces, ~, ~] = stlRead(path);
earModel.vertices = vertices .* 1e-3;
earModel.faces = faces;

% Calculate the base transform for the robot
t = [35 10 10] * 1e-3; % [mm]
R = [0 0 -1; 0 1 0; 1 0 0];
T = [R t'; 0 0 0 1];
earModel.baseTransform = T;

% Create a robot
alpha = pi;
cutouts = [];
cutouts.w = [1 1 1 1 1 1] * 1e-3;
cutouts.u = [1 1 1 1 1 1] * 1e-3;
cutouts.h = [1 1 1 1 1 1] * 1e-3;
cutouts.alpha = [0 0 0 alpha 0 0];
robot = Wrist(1.6e-3, 1.85e-3, 6, cutouts);

[qListNormalized,qList,pList,aList] = rrt(robot, ...
    [maxDisplacement maxRotation maxAdvancement], ...
    earModel, ...
    nPoints);

fprintf(['RRT execution complete. Total sampled points: ' num2str(size(qList,2)) ' \n\n']);

figure

% Visualize the robot inside the cavity
ii = 1;
h1 = stlPlot(earModel.vertices, earModel.faces, 'Collision detection test.');
hold on

robotPhysicalModel = robot.makePhysicalModel();
h2 = surf(robotPhysicalModel.surface.X, ...
    robotPhysicalModel.surface.Y, ...
    robotPhysicalModel.surface.Z, ...
    'FaceColor','blue');

axis equal

%for ii = 1 : size(pList, 2)
while true
    robot.fwkine(qList(:,ii), T);
    robotPhysicalModel = robot.makePhysicalModel();
    
    h2.XData = robotPhysicalModel.surface.X;
    h2.YData = robotPhysicalModel.surface.Y;
    h2.ZData = robotPhysicalModel.surface.Z;
    title(['Pose ' num2str(ii) ' of ' num2str(size(pList, 2))]);
    
    fprintf('Press "n" to move forward or "p" to move back.\n')
    fprintf('Press any other key to stop testing and generate the reachable workspace.\n\n')
    
    while ~waitforbuttonpress, end
    k = get(gcf, 'CurrentCharacter');
    
    switch k
        case 'p'
            ii = ii - 1;
            if ii < 1, ii = 1; end
        case 'n'
            ii = ii + 1;
            if ii > size(pList, 2), ii = size(pList, 2); end
        otherwise
            break
    end
end

close all

pList = pList * 1e3; % converting to mm for plotting

fprintf('\n Generating reachable workspace...\n')
shrinkFactor = 1;
[k,v] = boundary(pList(1,:)', pList(2,:)', pList(3,:)', shrinkFactor);

figure
scatter3(qList(1,:), qList(2,:), qList(3,:));
grid on
xlabel('Pull-wire fprintflacement [mm]');
ylabel('Axial rotation [rad]');
zlabel('Axial translation [mm]');
title('Configurations generated by RRT');

figure
scatter3(qListNormalized(1,:), qListNormalized(2,:), qListNormalized(3,:));
grid on
xlabel('Pull-wire fprintflacement [mm]');
ylabel('Axial rotation [rad]');
zlabel('Axial translation [mm]');
title('Configurations generated by RRT (normalized)');

% Visualize ear model
figure, hold on
stlPlot(vertices, faces, 'Synthetic Model');
view([17.8 30.2]);

scatter3(pList(1,:), pList(2,:), pList(3,:),'red','filled');
axis equal, grid on
xlabel('X [mm]'), ylabel('Y [mm]'), zlabel('Z [mm]');
title('Reachable points in the task space');

figure, hold on
stlPlot(vertices, faces, 'Synthetic Model');
view([17.8 30.2]);
trisurf(k, pList(1,:)', pList(2,:)', pList(3,:)','FaceColor','red','FaceAlpha',0.1)
title('Reachable workspace');

fprintf('Testing complete.\n')